{
  inputs,
  lib,
  ...
}:
{
  # Impermanence - persist only explicitly declared state
  # https://github.com/nix-community/impermanence
  #
  # This module provides infrastructure only. Individual service modules
  # should declare their own persistence needs using the pattern:
  #
  #   config = lib.mkIf (config ? impermanence) {
  #     impermanence.persistedDirectories = [ "/var/lib/myservice" ];
  #   };

  flake.modules.nixos.impermanence =
    { config, pkgs, ... }:
    let
      cfg = config.impermanence;

      # Script to check for untracked state
      impermanence-diff = pkgs.writeShellScriptBin "impermanence-diff" ''
        set -euo pipefail

        # Colors for output
        RED='\033[0;31m'
        YELLOW='\033[1;33m'
        GREEN='\033[0;32m'
        NC='\033[0m' # No Color

        # Build arrays from the NixOS configuration
        PERSISTED_FILES=(${lib.concatMapStringsSep " " (f: ''"${f}"'') cfg.persistedFiles})
        PERSISTED_DIRS=(${lib.concatMapStringsSep " " (d: ''"${d}"'') cfg.persistedDirectories})
        IGNORABLE=(${lib.concatMapStringsSep " " (p: ''"${p}"'') cfg.ignoredPaths})

        is_covered() {
          local path="$1"
          for p in "''${PERSISTED_FILES[@]}" "''${PERSISTED_DIRS[@]}" "''${IGNORABLE[@]}"; do
            if [[ "$path" == "$p" || "$path" == "$p"/* ]]; then
              return 0
            fi
          done
          return 1
        }

        found_untracked=false

        # Check /etc
        etc_untracked=$(find /etc -type f ! -type l 2>/dev/null | while read -r f; do
          if ! is_covered "$f"; then
            echo "  $f"
          fi
        done)

        if [[ -n "$etc_untracked" ]]; then
          found_untracked=true
          echo -e "''${YELLOW}=== Untracked files in /etc ===''${NC}"
          echo "$etc_untracked"
          echo ""
        fi

        # Check /var/lib
        varlib_untracked=$(find /var/lib -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read -r d; do
          if ! is_covered "$d"; then
            size=$(du -sh "$d" 2>/dev/null | cut -f1)
            echo "  $d ($size)"
          fi
        done)

        if [[ -n "$varlib_untracked" ]]; then
          found_untracked=true
          echo -e "''${YELLOW}=== Untracked directories in /var/lib ===''${NC}"
          echo "$varlib_untracked"
          echo ""
        fi

        if $found_untracked; then
          echo -e "''${RED}Untracked state found!''${NC} Add to the responsible module's impermanence config."
          exit 1
        else
          echo -e "''${GREEN}All state accounted for.''${NC}"
          exit 0
        fi
      '';
    in
    {
      imports = [ inputs.impermanence.nixosModules.impermanence ];

      options.impermanence = {
        enable = lib.mkOption {
          type = lib.types.bool;
          default = true;
          description = "Enable impermanence with Btrfs rollback.";
        };

        persistPath = lib.mkOption {
          type = lib.types.str;
          default = "/persist";
          description = "Path where persistent state is stored.";
        };

        wipeOnBoot = lib.mkOption {
          type = lib.types.bool;
          default = false;
          description = ''
            Whether to automatically wipe root on boot.
            When false, impermanence is configured but root is not wiped.
            Enable this only after verifying all needed state is persisted.
          '';
        };

        persistedFiles = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Files to persist across reboots.";
        };

        persistedDirectories = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Directories to persist across reboots.";
        };

        ignoredPaths = lib.mkOption {
          type = lib.types.listOf lib.types.str;
          default = [ ];
          description = "Paths that are safe to lose (generated on boot, caches, etc).";
        };
      };

      config = lib.mkIf cfg.enable {
        # Universal files that should be persisted on all systems
        impermanence.persistedFiles = [
          "/etc/machine-id"
          "/etc/adjtime"
        ];

        # Universal directories - nixos uid/gid state
        impermanence.persistedDirectories = [
          "/var/lib/nixos"
        ];

        # Paths generated by NixOS activation or safe to lose
        impermanence.ignoredPaths = [
          # /etc - generated by NixOS activation
          "/etc/NIXOS"
          "/etc/.clean"
          "/etc/.updated"
          "/etc/.pwd.lock"
          "/etc/passwd"
          "/etc/group"
          "/etc/shadow"
          "/etc/subuid"
          "/etc/subgid"
          "/etc/sudoers"
          "/etc/resolv.conf"
          "/etc/resolv.conf.bak"
          "/etc/kernel/entry-token"
          "/etc/nixos"
          # /var/lib/systemd - we persist specific subdirs, ignore the rest
          "/var/lib/systemd"
          # /var/lib - caches and regenerable state
          "/var/lib/AccountsService"
          "/var/lib/lastlog"
          "/var/lib/logrotate.status"
          "/var/lib/misc"
          "/var/lib/machines"
          "/var/lib/portables"
          "/var/lib/private"
          # Other ephemeral locations
          "/var/cache"
          "/root"
          "/srv"
          "/tmp"
          "/var/tmp"
        ];

        # Configure the impermanence module
        environment.persistence.${cfg.persistPath} = {
          hideMounts = true;
          files = cfg.persistedFiles;
          directories = cfg.persistedDirectories;
        };

        # Make the diff script available system-wide
        environment.systemPackages = [ impermanence-diff ];

        # Bootstrap: ensure persisted files exist in /persist and remove originals
        # so impermanence can create bind mounts. This runs before other activation scripts.
        system.activationScripts.impermanence-bootstrap = {
          text = ''
            echo "=== Impermanence Bootstrap ==="
            ${lib.concatMapStringsSep "\n" (file: ''
              # If file exists at original location but not in persist, copy it
              if [[ -e "${file}" && ! -L "${file}" && ! -e "${cfg.persistPath}${file}" ]]; then
                echo "Copying ${file} -> ${cfg.persistPath}${file}"
                mkdir -p "$(dirname "${cfg.persistPath}${file}")"
                cp -a "${file}" "${cfg.persistPath}${file}"
              fi
              # Remove original file (if not already a symlink/mount) so bind mount can be created
              if [[ -e "${file}" && ! -L "${file}" ]] && mountpoint -q "${file}" 2>/dev/null; then
                : # Already a mount point, leave it alone
              elif [[ -f "${file}" && ! -L "${file}" && -e "${cfg.persistPath}${file}" ]]; then
                echo "Removing ${file} to allow bind mount"
                rm -f "${file}"
              fi
            '') cfg.persistedFiles}
            echo "=== Bootstrap complete ==="
          '';
          deps = [ ];
        };

        # Post-rebuild activation script to warn about untracked state
        # Runs after other scripts via deps on "usrbinenv" (one of the last standard scripts)
        system.activationScripts.impermanence-check = {
          text = ''
            echo ""
            echo "=== Impermanence State Check ==="
            if ${impermanence-diff}/bin/impermanence-diff; then
              echo "=== Impermanence: OK ==="
            else
              echo ""
              echo "WARNING: Untracked state detected!"
              echo "Run 'impermanence-diff' for details."
              echo "=== Impermanence: ATTENTION NEEDED ==="
            fi
            echo ""
          '';
          deps = [ "usrbinenv" ];
        };

        # Btrfs rollback on boot (only if wipeOnBoot is enabled)
        boot.initrd.systemd.services.rollback = lib.mkIf cfg.wipeOnBoot {
          description = "Rollback root filesystem to blank snapshot";
          wantedBy = [ "initrd.target" ];
          before = [ "sysroot.mount" ];
          unitConfig.DefaultDependencies = "no";
          serviceConfig.Type = "oneshot";
          script = ''
            mkdir -p /mnt
            mount -o subvol=/ /dev/disk/by-label/NIXOS /mnt

            # Keep a backup of the old root
            if [[ -e /mnt/@root ]]; then
              timestamp=$(date +%Y%m%d-%H%M%S)
              mv /mnt/@root /mnt/@root-old-$timestamp
            fi

            # Delete old backups, keep last 3
            for old in $(ls -1d /mnt/@root-old-* 2>/dev/null | sort -r | tail -n +4); do
              btrfs subvolume delete "$old"
            done

            # Create fresh root from blank snapshot
            btrfs subvolume snapshot /mnt/@root-blank /mnt/@root

            umount /mnt
          '';
        };
      };
    };
}
